extern crate ndarray_linalg;
extern crate ndarray_parallel;
extern crate ndarray_stats;

#[macro_use]
extern crate ndarray;

use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

use ndarray::prelude::*;
use ndarray::Zip;

use ndarray_parallel::prelude::*;

use ndarray_linalg::norm::Norm;

use std::time::Instant;

fn convert(phi: Vec<Vec<Vec<f64>>>) -> Array3<f64> {
    let flattened: Vec<f64> = phi.concat().concat();
    let init = Array3::from_shape_vec((phi.len(), phi[0].len(), phi[0][0].len()), flattened);
    init.unwrap()
}

/// Calculates the magnetic field, B, generated by a current density, J
///
/// Parameters
/// ----------
/// jx : ndarray
///     Values of Jx on a 3D grid. Has to be a matrix of size MxNxK.
/// jy : ndarray
///     Values of Jy on a 3D grid. Has to be a matrix of size MxNxK.
/// jz : ndarray
///     Values of Jz on a 3D grid. Has to be a matrix of size MxNxK.
/// x_cor : array_like
///     X coordinates for the first dimension of the J values grid.
/// y_cor : array_like
///     Y coordinates for the second dimension of the J values grid.
/// z_cor : array_like
///     Z coordinates for the third dimension of the J values grid.
///
/// Returns
/// -------
/// B : tuple of array_like
///     tuple of Bx, By and Bz. Each list has to be reshaped to match the original size of J.
///
/// Note
/// ----
/// Parallelized through the use of ndarray-parallel.
#[pyfunction]
fn biot(
    jx: Vec<Vec<Vec<f64>>>,
    jy: Vec<Vec<Vec<f64>>>,
    jz: Vec<Vec<Vec<f64>>>,
    x_cor: Vec<f64>,
    y_cor: Vec<f64>,
    z_cor: Vec<f64>,
) -> PyResult<(Vec<f64>, Vec<f64>, Vec<f64>)> {
    let jx = convert(jx);
    let jy = convert(jy);
    let jz = convert(jz);

    let mut b_x = Array3::<f64>::zeros(jx.dim());
    let mut b_y = Array3::<f64>::zeros(jy.dim());
    let mut b_z = Array3::<f64>::zeros(jz.dim());
    let mu0 = 1.256_637_0614e-6; //mu_0 in units of Tesla*meter/Ampere

    println!("starting calculations");
    Zip::indexed(&mut b_x)
        .and(&mut b_y)
        .and(&mut b_z)
        .par_apply(|idx, result_x, result_y, result_z| {
            let b_r = array![
                x_cor[idx.0] as f64,
                y_cor[idx.1] as f64,
                z_cor[idx.2] as f64
            ];

            for (xi, x) in x_cor.iter().enumerate() {
                for (yi, y) in y_cor.iter().enumerate() {
                    for (zi, z) in z_cor.iter().enumerate() {
                        let jx_val = &jx[[xi, yi, zi]];
                        let jy_val = &jy[[xi, yi, zi]];
                        let jz_val = &jz[[xi, yi, zi]];

                        let r_mark = array![*x, *y, *z];
                        let r = &b_r - &r_mark;
                        let r3 = r.norm_l2().powf(3.0);

                        if r3 != 0.0 {
                            *result_x += (-r[1] * jz_val + jy_val * r[2]) / &r3;
                            *result_y += (r[0] * jz_val - jx_val * r[2]) / &r3;
                            *result_z += (-r[0] * jy_val + jx_val * r[1]) / &r3;
                        }
                    }
                }
            }
            *result_x *= mu0;
            *result_y *= mu0;
            *result_z *= mu0;
        });

    println!("calculations done");
    println!("sums: ");
    println!("x: {}", b_x.sum());
    println!("y: {}", b_y.sum());
    println!("z: {}", b_z.sum());
    println!("=======");

    println!("shapes");
    println!("x: {:?}", b_x.shape());
    println!("y: {:?}", b_y.shape());
    println!("z: {:?}", b_z.shape());

    Ok((b_x.into_raw_vec(), b_y.into_raw_vec(), b_z.into_raw_vec()))
}

#[pymodule]
fn libbiot_savart(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_wrapped(wrap_pyfunction!(biot))?;

    Ok(())
}
