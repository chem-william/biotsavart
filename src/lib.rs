extern crate ndarray_linalg;
extern crate ndarray_parallel;

#[macro_use]
extern crate ndarray;

use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

use ndarray::prelude::*;
use ndarray::Zip;

use ndarray_parallel::prelude::*;

use ndarray_linalg::norm::Norm;

fn convert(phi: Vec<Vec<Vec<f64>>>) -> Array3<f64> {
    let flattened: Vec<f64> = phi.concat().concat();
    let init = Array3::from_shape_vec((phi.len(), phi[0].len(), phi[0][0].len()), flattened);
    init.unwrap()
}

// Calculates the magnetization in accordance to the paper
// "Local Current Density Calculations for Molecular Films from Ab Initio"
// DOI: 10.1021/acs.jctc.5b00471
// J. Chem. Theory Comput. 2015, 11, 5161âˆ’5176

// TODO: in the paper it uses the negative of the current density. I don't. Is that bad?
fn calculate_magnetization(
    center: Array1<f64>,
    jx: &Array3<f64>,
    jy: &Array3<f64>,
    jz: &Array3<f64>,
    x_cor: &Vec<f64>,
    y_cor: &Vec<f64>,
    z_cor: &Vec<f64>,
) -> Vec<f64> {
    let mut temp_x = Array3::<f64>::zeros(jx.dim());
    let mut temp_y = Array3::<f64>::zeros(jy.dim());
    let mut temp_z = Array3::<f64>::zeros(jz.dim());

    Zip::indexed(&mut temp_x)
        .and(&mut temp_y)
        .and(&mut temp_z)
        .par_apply(|idx, result_x, result_y, result_z| {
            let b_r = array![
                x_cor[idx.0] as f64,
                y_cor[idx.1] as f64,
                z_cor[idx.2] as f64
            ] - &center;
            let jx_val = &jx[[idx.0, idx.1, idx.2]];
            let jy_val = &jy[[idx.0, idx.1, idx.2]];
            let jz_val = &jz[[idx.0, idx.1, idx.2]];

            *result_x = -b_r[1] * jz_val + jy_val * b_r[2];
            *result_y = b_r[0] * jz_val - jx_val * b_r[2];
            *result_z = -b_r[0] * jy_val + jx_val * b_r[1];
        });

    vec![temp_x.sum() * 0.5, temp_y.sum() * 0.5, temp_z.sum() * 0.5]
}

/// Calculates the magnetic field, B, generated by a current density, J
///
/// Parameters
/// ----------
/// center : ndarray
///     Array of x-, y-, z- coordinates where the magnetization is calculated
/// jx : ndarray
///     Values of Jx on a 3D grid. Has to be a matrix of size MxNxK.
/// jy : ndarray
///     Values of Jy on a 3D grid. Has to be a matrix of size MxNxK.
/// jz : ndarray
///     Values of Jz on a 3D grid. Has to be a matrix of size MxNxK.
/// x_cor : array_like
///     X coordinates for the first dimension of the J values grid.
/// y_cor : array_like
///     Y coordinates for the second dimension of the J values grid.
/// z_cor : array_like
///     Z coordinates for the third dimension of the J values grid.
///
/// Returns
/// -------
/// B : tuple of array_like
///     tuple of Bx, By and Bz. Each list has to be reshaped to match the original size of J.
///
/// Note
/// ----
/// Parallelized through the use of ndarray-parallel.
#[pyfunction]
fn biot(
    center: Vec<f64>,
    jx: Vec<Vec<Vec<f64>>>,
    jy: Vec<Vec<Vec<f64>>>,
    jz: Vec<Vec<Vec<f64>>>,
    x_cor: Vec<f64>,
    y_cor: Vec<f64>,
    z_cor: Vec<f64>,
) -> PyResult<(Vec<f64>, Vec<f64>, Vec<f64>, Vec<f64>)> {
    let center = Array1::from(center);
    let jx = convert(jx);
    let jy = convert(jy);
    let jz = convert(jz);

    let mut b_x = Array3::<f64>::zeros(jx.dim());
    let mut b_y = Array3::<f64>::zeros(jy.dim());
    let mut b_z = Array3::<f64>::zeros(jz.dim());

    println!("Calculating m..");
    let m_vec = calculate_magnetization(center, &jx, &jy, &jz, &x_cor, &y_cor, &z_cor);

    Zip::indexed(&mut b_x)
        .and(&mut b_y)
        .and(&mut b_z)
        .par_apply(|idx, result_x, result_y, result_z| {
            let b_r = array![
                x_cor[idx.0] as f64,
                y_cor[idx.1] as f64,
                z_cor[idx.2] as f64
            ];

            for (xi, x) in x_cor.iter().enumerate() {
                for (yi, y) in y_cor.iter().enumerate() {
                    for (zi, z) in z_cor.iter().enumerate() {
                        let jx_val = &jx[[xi, yi, zi]];
                        let jy_val = &jy[[xi, yi, zi]];
                        let jz_val = &jz[[xi, yi, zi]];

                        let r_mark = array![*x, *y, *z];
                        let r = &b_r - &r_mark;
                        let r3 = r.norm_l2().powf(3.0);

                        if r3 != 0.0 {
                            *result_x += -(-r[1] * jz_val + jy_val * r[2]) / r3;
                            *result_y += -(r[0] * jz_val - jx_val * r[2]) / r3;
                            *result_z += -(-r[0] * jy_val + jx_val * r[1]) / r3;
                        }
                    }
                }
            }
        });
    b_x *= -1.0;
    b_y *= -1.0;
    b_z *= -1.0;

    Ok((
        b_x.into_raw_vec(),
        b_y.into_raw_vec(),
        b_z.into_raw_vec(),
        m_vec,
    ))
}

#[pymodule]
fn libbiot_savart(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_wrapped(wrap_pyfunction!(biot))?;

    Ok(())
}
